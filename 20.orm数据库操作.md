# 1.了解orm



`ORM（对象关系映射）是一种将对象模型与关系数据库之间进行转换和映射的技术。它允许开发人员在编程语言中使用面向对象的方式来操作数据库，而无需直接编写SQL语句。`

`通过使用ORM，开发人员可以将数据库表和记录映射到对象和属性上，从而可以使用面向对象的方式进行数据库操作。ORM提供了一组API和工具，用于执行常见的数据库操作，如插入、更新、删除和查询等。`

```
抽象数据库细节：ORM隐藏了底层数据库的细节，使开发人员可以专注于业务逻辑的实现，而不必过多关注数据库操作的细节。

提高开发效率：ORM提供了简洁的API和查询语言，可以更快速地进行数据库操作，减少了编写和调试SQL语句的工作量。

跨数据库支持：ORM通常支持多种数据库系统，并提供了跨数据库的一致性接口，这样开发人员可以轻松切换或同时支持多个数据库。

对象化数据访问：ORM将数据库表和记录映射为对象和属性，使得数据访问更加直观和方便，可以像操作普通对象一样对数据库进行增删改查操作。

数据库迁移和版本控制：ORM通常提供了数据库迁移和版本控制的功能，使得数据库的结构变更和更新更加方便和可控。
```



# 2.django orm

```
Django ORM（对象关系映射）是Django框架中内置的一种ORM工具，用于在Python应用程序中与数据库进行交互。它提供了一个高级的API和查询语言，使开发人员可以使用面向对象的方式来操作数据库，而无需编写原始的SQL语句。
```

```
对象关系映射：Django ORM将数据库表映射为Python类，将表中的记录映射为对象实例，将表中的字段映射为对象的属性。这样，开发人员可以使用Python代码来操作数据库，而不需要直接编写SQL语句。

数据库迁移：Django ORM提供了数据库迁移的功能，可以通过命令行工具自动检测和应用数据库模型的变更，使数据库的结构与应用程序的模型保持同步。

查询语言：Django ORM提供了强大而灵活的查询API，可以执行各种复杂的查询操作，如过滤、排序、聚合、连接等。开发人员可以使用链式调用的方式来构建查询，并获得需要的结果集。

数据关系管理：Django ORM支持定义和管理数据之间的关系，包括一对一、一对多和多对多关系。开发人员可以通过简单的API来处理相关的数据操作，如创建、更新和删除关联对象。

缓存支持：Django ORM提供了缓存机制，可以缓存查询结果以提高性能。开发人员可以选择使用内存缓存或其他第三方缓存后端来加速数据库访问。

数据库支持：Django ORM支持多种主流数据库系统，如MySQL、PostgreSQL、SQLite和Oracle等，通过简单的配置即可连接到不同的数据库。

事务管理：Django ORM支持事务操作，可以确保多个数据库操作的原子性，保证数据的一致性。
```

```python
# pip install pymysql

# setting同级的__init__.py
from pymysql import install_as_MySQLdb
install_as_MySQLdb()


# setting
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'your_database_name',
        'USER': 'your_username',
        'PASSWORD': 'your_password',
        'HOST': 'localhost',
        'PORT': '3306',
    }
}

```





# 3.模型类-字段

```
字段类型
```

| 字段类型       | 关键字属性                  | 作用和参数情况                                               |
| -------------- | --------------------------- | ------------------------------------------------------------ |
| 整数字段       | `AutoField`                 | 自增整数字段，一般用作主键。无需指定参数。                   |
|                | `BigAutoField`              | 自增长的64位整数字段，一般用作主键。无需指定参数。           |
|                | `BigIntegerField`           | 大整数字段。无需指定参数。                                   |
|                | `IntegerField`              | 整数字段。无需指定参数。                                     |
|                | `PositiveIntegerField`      | 正整数字段。无需指定参数。                                   |
|                | `PositiveSmallIntegerField` | 正小整数字段。无需指定参数。                                 |
|                | `SmallIntegerField`         | 小整数字段。无需指定参数。                                   |
| 浮点数字段     | `DecimalField`              | 十进制数字字段。需要指定`max_digits`和`decimal_places`参数。 |
|                | `FloatField`                | 浮点数字段。无需指定参数。                                   |
|                | `PositiveDecimalField`      | 正十进制数字字段。需要指定`max_digits`和`decimal_places`参数。 |
|                | `PositiveFloatField`        | 正浮点数字段。无需指定参数。                                 |
| 字符串字段     | `CharField`                 | 字符串字段。需要指定`max_length`参数。                       |
|                | `TextField`                 | 文本字段，可以存储大段文本。无需指定参数。                   |
|                | `SlugField`                 | Slug字段，用于存储URL友好的字符串。需要指定`max_length`参数。 |
| 日期时间字段   | `DateField`                 | 日期字段，存储年月日。可以指定`auto_now`参数。               |
|                | `DateTimeField`             | 日期时间字段，存储年月日时分秒。可以指定`auto_now`参数。     |
|                | `TimeField`                 | 时间字段，存储时分秒。可以指定`auto_now`参数。               |
|                | `DurationField`             | 时间段字段。无需指定参数。                                   |
| 布尔值字段     | `BooleanField`              | 布尔值字段，只能存储True或False。可以指定`default`参数。     |
|                | `NullBooleanField`          | 允许为空的布尔值字段。无需指定参数。                         |
| 二进制数据字段 | `BinaryField`               | 二进制数据字段。可以指定`max_length`参数。                   |
|                | `ImageField`                | 图片上传字段。可以指定`upload_to`参数。                      |
|                | `FileField`                 | 文件上传字段。可以指定`upload_to`参数。                      |



```
关系字段
```

| 关系类型       | 关键字属性        | 作用和参数情况                                               |
| -------------- | ----------------- | ------------------------------------------------------------ |
| 外键字段       | `ForeignKey`      | 外键字段，用于与其他模型类建立多对一的关联。需要指定关联的模型类作为参数，并可选地指定`on_delete`参数来设置关联模型被删除时的行为。 |
| 一对一关系字段 | `OneToOneField`   | 一对一关系字段，用于与另一个模型类建立一对一的关联。需要指定关联的模型类作为参数，并可选地指定`on_delete`参数来设置关联模型被删除时的行为。 |
| 多对多关系字段 | `ManyToManyField` | 多对多关系字段，用于与其他模型类建立多对多的关联。需要指定关联的模型类作为参数。 |



```
特定数据类型字段
```

| 数据类型     | 关键字属性        | 作用和参数情况                                               |
| ------------ | ----------------- | ------------------------------------------------------------ |
| JSON字段     | `JSONField`       | JSON数据字段，用于存储和查询JSON格式的数据。无需指定参数。   |
|              | `BinaryJSONField` | 二进制JSON字段，用于存储和查询二进制格式的JSON数据。无需指定参数。 |
| 数组字段     | `ArrayField`      | 数组字段，用于存储数组类型的数据。需要指定`base_field`参数来指定数组中元素的数据类型，以及可选的`size`参数来限制数组的大小。 |
| 键值对字段   | `HStoreField`     | 键值对字段，用于存储和查询键值对数据。无需指定参数。         |
| XML字段      | `XMLField`        | XML字段，用于存储和查询XML数据。无需指定参数。               |
| 文件路径字段 | `FilePathField`   | 文件路径字段，用于存储文件系统中的文件路径。可以指定`path`参数来指定文件路径的起始位置，并可选地指定`match`参数来过滤文件名的匹配规则。 |
| IP地址字段   | `IPAddressField`  | IP地址字段，用于存储IP地址。无需指定参数。                   |
| UUID字段     | `UUIDField`       | UUID字段，用于存储全局唯一标识符(UUID)。无需指定参数。       |



```python
特定数据类型字段
```

| 数据类型     | 关键字属性        | 作用和参数情况                                               |
| ------------ | ----------------- | ------------------------------------------------------------ |
| JSON字段     | `JSONField`       | JSON数据字段，用于存储和查询JSON格式的数据。无需指定参数。   |
|              | `BinaryJSONField` | 二进制JSON字段，用于存储和查询二进制格式的JSON数据。无需指定参数。 |
| 数组字段     | `ArrayField`      | 数组字段，用于存储数组类型的数据。需要指定`base_field`参数来指定数组中元素的数据类型，以及可选的`size`参数来限制数组的大小。 |
| 键值对字段   | `HStoreField`     | 键值对字段，用于存储和查询键值对数据。无需指定参数。         |
| XML字段      | `XMLField`        | XML字段，用于存储和查询XML数据。无需指定参数。               |
| 文件路径字段 | `FilePathField`   | 文件路径字段，用于存储文件系统中的文件路径。可以指定`path`参数来指定文件路径的起始位置，并可选地指定`match`参数来过滤文件名的匹配规则。 |
| IP地址字段   | `IPAddressField`  | IP地址字段，用于存储IP地址。无需指定参数。                   |
| UUID字段     | `UUIDField`       | UUID字段，用于存储全局唯一标识符(UUID)。无需指定参数。       |



```python
其他字段
```

| 其他字段         | 关键字属性           | 作用和参数情况                                               |
| ---------------- | -------------------- | ------------------------------------------------------------ |
| URL字段          | `URLField`           | URL字段，用于存储URL地址。可以指定`max_length`参数来限制字符串的最大长度。 |
| 时区字段         | `TimezoneField`      | 时区字段，用于存储时区信息。无需指定参数。                   |
| 日期范围字段     | `DateRangeField`     | 日期范围字段，用于存储日期范围。无需指定参数。               |
| 日期时间范围字段 | `DateTimeRangeField` | 日期时间范围字段，用于存储日期时间范围。无需指定参数。       |



# 4.模型类-选项参数

```
null：指定字段是否允许为空值。默认为False。
blank：指定字段在表单中是否可以为空。默认为False。
default：指定字段的默认值。
primary_key：将字段设置为主键。
unique：指定字段的值是否必须唯一。
db_index：指定是否为该字段创建数据库索引。
choices：为字段提供一个可选的选择列表。
verbose_name：指定字段在管理界面中显示的名称。
help_text：为字段提供一个描述性的帮助文本。
related_name：指定反向关系的名称。
```

| 选项参数       | 包含该选项参数的字段类型                                     |
| -------------- | ------------------------------------------------------------ |
| `null`         | `IntegerField`, `PositiveIntegerField`, `SmallIntegerField`, `FloatField`, `DecimalField`, `CharField`, `TextField`, `SlugField`, `DateField`, `DateTimeField`, `TimeField`, `BooleanField`, `NullBooleanField`, `BinaryField`, `ImageField`, `FileField`, `ForeignKey`, `OneToOneField`, `ManyToManyField` |
| `blank`        | `IntegerField`, `PositiveIntegerField`, `SmallIntegerField`, `FloatField`, `DecimalField`, `CharField`, `TextField`, `SlugField`, `DateField`, `DateTimeField`, `TimeField`, `BooleanField`, `NullBooleanField`, `BinaryField`, `ImageField`, `FileField`, `ForeignKey`, `OneToOneField`, `ManyToManyField` |
| `default`      | `IntegerField`, `PositiveIntegerField`, `SmallIntegerField`, `FloatField`, `DecimalField`, `CharField`, `TextField`, `SlugField`, `DateField`, `DateTimeField`, `TimeField`, `BooleanField`, `NullBooleanField`, `BinaryField`, `ImageField`, `FileField`, `ForeignKey`, `OneToOneField` |
| `primary_key`  | `AutoField`                                                  |
| `unique`       | `IntegerField`, `PositiveIntegerField`, `SmallIntegerField`, `FloatField`, `DecimalField`, `CharField`, `SlugField`, `DateField`, `DateTimeField`, `TimeField`, `BooleanField`, `NullBooleanField`, `BinaryField`, `ImageField`, `FileField`, `ForeignKey`, `OneToOneField` |
| `db_index`     | `IntegerField`, `PositiveIntegerField`, `SmallIntegerField`, `FloatField`, `DecimalField`, `CharField`, `SlugField`, `DateField`, `DateTimeField`, `TimeField`, `BooleanField`, `NullBooleanField`, `BinaryField`, `ImageField`, `FileField`, `ForeignKey`, `OneToOneField`, `ManyToManyField` |
| `choices`      | `IntegerField`, `PositiveIntegerField`, `SmallIntegerField`, `CharField`, `SlugField` |
| `verbose_name` | 所有字段类型                                                 |
| `help_text`    | 所有字段类型                                                 |
| `related_name` | `ForeignKey`, `OneToOneField`, `ManyToManyField`             |



# 5.建立模型类

```python
from django.db import models

class Student(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    age = models.IntegerField()
    email = models.EmailField()
    date_of_birth = models.DateField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

```

```python
# 在Django ORM中，默认情况下，每个模型类都会自动创建一个名为id的主键字段。这是由AutoField类型实现的自增长整数字段。
```

```python
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=50, verbose_name='姓名')
    bio = models.TextField(verbose_name='简介')
    birth_date = models.DateField(verbose_name='出生日期')

    def __str__(self):
        return self.name


class Book(models.Model):
    title = models.CharField(max_length=100, verbose_name='书名')
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books', verbose_name='作者')
    publication_date = models.DateField(verbose_name='出版日期')
    price = models.DecimalField(max_digits=5, decimal_places=2, verbose_name='价格')

    def __str__(self):
        return self.title

"""
定义了两个模型类：Author和Book。Author表示作者，而Book表示书籍。

在Author模型中，我们定义了几个字段，包括name（姓名）、bio（简介）和birth_date（出生日期）。这些字段用于存储作者的相关信息。

在Book模型中，我们使用ForeignKey字段来建立与Author模型的一对多关系。author字段是一个外键字段，它指向Author模型作为关联对象。通过设置on_delete=models.CASCADE参数，我们指定当关联的Author对象被删除时，与之关联的Book对象也将被级联删除。此外，我们还添加了publication_date（出版日期）和price（价格）字段，用于存储书籍的相关信息。

注意，在ForeignKey字段中，我们使用了related_name='books'参数来指定反向关系的名称。这允许通过Author对象访问与之关联的所有书籍。

通过这样的模型定义，每本书都会与一个作者相关联，而每个作者可以有多本书。您可以根据具体需求扩展这两个模型类，添加更多的字段和属性。
"""

```



# 6.迁移建表

```python
# 创建迁移文件
python manage.py makemigrations
"""
这将自动生成一个迁移文件，其中包含了数据库模式更改的信息。
"""
```



```python
# 应用迁移文件并将表结构同步到数据库
python manage.py migrate
"""
这将应用生成的迁移文件，创建数据库表格或更新已存在的表格，以反映模型的定义。
"""
```



```
在Django中，迁移记录表的名称是django_migrations。它是用来记录每个已应用的迁移文件的表格。

当您运行python manage.py migrate命令时，Django将会检查django_migrations表来确定哪些迁移文件已经被应用到数据库中，以避免重复应用相同的迁移。

django_migrations表有以下列：

id: 自增主键
app: 迁移所属的应用名称
name: 迁移文件的名称 -- 每次改变都会在makemigrations时进行校验及生成迁移文件（文件名会涉及到标识信息）
applied: 迁移文件应用的日期和时间
```



# 7.Django交互式Python shell

```shell
python manage.py shell

# 通过运行这个命令，您可以在一个类似于Python终端的环境中与您的Django项目进行交互
```



# 8.添加数据

```python
# save: 实例模型类，对象并保存到数据库

from myapp.models import Author, Book

# 创建Author对象并保存到数据库
author = Author(name='John Doe', bio='A famous author', birth_date='1990-01-01')
author.save()

# 创建Book对象并保存到数据库
book = Book(title='Sample Book', author=author, publication_date='2023-01-01', price='19.99')
book.save()
```

```python
# create()方法直接创建并保存对象
from myapp.models import Author, Book
author = Author.objects.create(name='John Doe', bio='A famous author', birth_date='1990-01-01')

book = Book.objects.create(title='Sample Book', author=author, publication_date='2023-01-01', price='19.99')
```



# 9.删除数据

```python
# 删除单个记录

from myapp.models import Book

# 根据id删除指定的图书
book = Book.objects.get(id=1)
book.delete()
```

```python
# 使用过滤条件批量删除记录

# 删除价格等于20的所有图书
Book.objects.filter(price=20).delete()

# 删除名为"John Doe"的所有图书
Book.objects.filter(author="John Doe").delete()
```



```python
# 还可以使用bulk_delete()方法进行批量删除，该方法会直接执行SQL语句而不加载模型对象。这样可以提高删除效率，尤其是对于大批量的数据删除操作

from myapp.models import Book

# 删除价格等于20的所有图书
Book.objects.filter(price=20).bulk_delete()
```



# 10.修改数据

```python
# 修改单个记录

from myapp.models import Book

# 获取要修改的图书对象
book = Book.objects.get(id=1)

# 修改图书的价格
book.price = 29.99

# 保存修改后的图书对象到数据库
book.save()
```



```python
# 使用 update() 方法，不会触发模型的信号处理程序、验证器或自定义 save() 方法。它直接在数据库层面执行更新操作，因此更高效。

from myapp.models import Book

# 将价格等于20的所有图书的价格 改为 10
Book.objects.filter(price__gt=20).update(price=10)

```







# 11.查询数据--基础查询

```python
# all 查询所有记录：返回指定模型的所有记录

from myapp.models import Book

books = Book.objects.all()  # Book 模型的所有对象

```



```python
# get(**kwargs): 根据指定的筛选条件返回单个对象。如果没有符合条件的对象或找到多个符合条件的对象，会引发异常

books = Book.objects.get(id=1)
```



```python
# filter(**kwargs): 根据指定的筛选条件返回满足条件的多个对象。它返回一个 QuerySet 对象，可以进一步操作或迭代。

books = Book.objects.filter(price=20)  # 返回价格等于 20 的所有 Book 对象
```



```python
# first(): 返回满足查询条件的第一个对象。它等效于使用 filter() 方法并选择第一个对象。

books = Book.objects.filter(author="John Doe").first()  # 返回作者名为 "John Doe" 的第一本书
```



```python
# count() 方法来计算满足指定条件的记录数

from myapp.models import Book

# 统计所有图书的数量
total_books = Book.objects.count()
```



# 12.查询数据--过滤查询



`在Django ORM 中，可以使用 `filter()` 方法对数据库进行过滤查询。该方法允许您指定一个或多个条件来筛选出满足条件的记录。`

```python
# 等值查询/相等查询(Equal Query）

from myapp.models import Book

# 查询作者名为 "John Doe" 的图书
books = Book.objects.filter(author="John Doe")

# 查询价格为 19.99 的图书
books = Book.objects.filter(price=19.99)
```



```python
# 包含查询（Contains Query）

from myapp.models import Book

# 查询标题中包含 "Python" 的图书
books = Book.objects.filter(title__contains="Python")

# 查询作者名中包含 "Doe" 的图书
books = Book.objects.filter(author__contains="Doe")
```



```python
# 模糊查询（Fuzzy Query）

"""
使用 contains 进行包含查询(区分大小写)
"""
from myapp.models import Book

# 查询标题中包含 "Python" 的图书
books = Book.objects.filter(title__contains="Python")


"""
使用 icontains 进行不区分大小写的包含查询
"""
from myapp.models import Book

# 查询作者名中包含 "doe" 的图书（不区分大小写）
books = Book.objects.filter(author__icontains="doe")


"""
使用 startswith 进行以指定字符串开头的查询
"""
from myapp.models import Book

# 查询作者名中包含 "doe" 的图书（不区分大小写）
books = Book.objects.filter(author__icontains="doe")


"""
使用 istartswith 进行不区分大小写的以指定字符串开头的查询
"""
from myapp.models import Book

books = Book.objects.filter(author__istartswith="john")


"""
使用 endswith 进行以指定字符串结尾的查询
"""
from myapp.models import Book

# 查询标题以 "Guide" 结尾的图书
books = Book.objects.filter(title__endswith="Guide")


"""
使用 iendswith 进行不区分大小写的以指定字符串结尾的查询
"""

from myapp.models import Book

# 查询作者名以 "doe" 结尾的图书（不区分大小写）
books = Book.objects.filter(author__iendswith="doe")
```



```python
# 空查询（Null Query）
"""
通过使用 __isnull 条件，可以根据字段是否为空来进行查询过滤
"""

from myapp.models import Book

# 查询没有设置出版日期的图书     查询为空（NULL）的记录
books = Book.objects.filter(publication_date__isnull=True)

# 查询设置了出版日期的图书     查询不为空（非NULL）的记录
books = Book.objects.filter(publication_date__isnull=False)
```





```python
# 范围查询（Range Query）

"""
range 条件来执行范围查询。范围查询允许您筛选出在指定值范围内的记录。
"""
from myapp.models import Book

# 查询价格大于等于 10 且小于等于 20 的图书
books = Book.objects.filter(price__range=(10, 20))

# 查询销量在 100 到 500 之间的图书
books = Book.objects.filter(sales__range=(100, 500))

```





```python
# 比较查询（Comparison Query）
"""
大于（Greater Than）查询 
gt 大于
"""
from myapp.models import Book

# 查询价格大于 20 的图书
books = Book.objects.filter(price__gt=20)


"""
小于（Less Than）查询：
lt 小于
"""
from myapp.models import Book

# 查询价格小于 50 的图书
books = Book.objects.filter(price__lt=50)



"""
大于等于（Greater Than or Equal To）查询
gte 大于等于
"""
from myapp.models import Book

# 查询价格大于等于 20 的图书
books = Book.objects.filter(price__gte=20)


"""
小于等于（Less Than or Equal To）查询
lte 小于等于
"""
from myapp.models import Book

# 查询价格小于等于 50 的图书
books = Book.objects.filter(price__lte=50)
```



```python
# 日期查询（Date Query）
"""
range 条件来执行范围查询。范围查询允许您筛选出在指定值范围内的记录。
"""
from myapp.models import Book
from datetime import date

# 查询出版日期在指定范围内的图书
start_date = date(2023, 1, 1)
end_date = date(2023, 12, 31)
books = Book.objects.filter(publication_date__range=(start_date, end_date))
```



```python
# 排除查询

"""
在 Django 中进行排除查询，可以使用模型管理器（objects）的 exclude() 方法
"""

from datetime import date
excluded_books = Book.objects.exclude(publication_date__lt=date(2022, 1, 1))  # 排除出版日期早于某个日期的书籍

excluded_books = Book.objects.exclude(price__gt=50) # 排除价格高于某个阈值的书籍

excluded_books = Book.objects.exclude(publication_date__lt=date(2022, 1, 1)).exclude(price__gt=50) # 使用多个条件进行链式排除查询
```



```python
# 多条件查询

books = Book.objects.filter(author="John Doe", price__lt=20)
```



# 13.Q对象

```
在Django ORM 中，Q 对象是用于构建复杂查询条件的工具。它允许您使用逻辑运算符（如 | 和 &）组合多个查询条件，并通过使用括号来定义优先级。
```

```python
from myapp.models import Book
from django.db.models import Q

# 查询价格小于 20 或作者名为 "John Doe" 的图书
books = Book.objects.filter(Q(price__lt=20) | Q(author="John Doe"))

# 查询标题以 "Python" 开头且价格大于等于 50 的图书，或者出版日期晚于指定日期的图书
start_date = datetime.date(2023, 1, 1)
books = Book.objects.filter(Q(title__startswith="Python", price__gte=50) | Q(publication_date__gt=start_date))

```





# 14.F对象

```python
在Django ORM 中，F() 对象用于在数据库级别执行字段之间的比较和操作。它允许您在查询中引用模型字段，并使用它们进行数学运算或比较。

通过使用 F() 对象，可以在查询中引用字段并进行复杂的比较和操作。这样可以使查询更加灵活和高效。

请注意，F() 对象只能在查询过程中使用，不能直接在模型对象上使用。它是为了在数据库层面执行操作而设计的。
```



```python
# 在查询中进行数学运算

from myapp.models import Book

# 将价格大于20的所有图书的价格减半
Book.objects.filter(price__gt=20).update(price=models.F('price') / 2)
```



```python
# 在查询中进行比较运算
from myapp.models import Book

# 查询价格大于平均价格的图书
average_price = Book.objects.aggregate(avg_price=models.Avg('price'))['avg_price']
books = Book.objects.filter(price__gt=average_price)

```



```python
# 在查询中对多个字段进行比较
from myapp.models import Book

# 查询价格大于库存的图书
books = Book.objects.filter(price__gt=models.F('stock'))
```





# 15.聚合查询

```
在Django ORM中，聚合查询用于计算数据库中的聚合值，如平均值、总和、最大值、最小值等。可以使用aggregate()方法来执行聚合查询。

aggregate() 是一个用于执行聚合查询的方法。它允许您计算数据库中的聚合值，并将结果作为字典返回。

aggregate() 方法接受一个或多个聚合函数作为参数，并为每个聚合函数指定一个别名。
```

| 聚合函数   | 功能                                                         |
| ---------- | ------------------------------------------------------------ |
| Avg        | 计算指定字段的平均值                                         |
| Sum        | 计算指定字段的总和                                           |
| Max        | 获取指定字段的最大值                                         |
| Min        | 获取指定字段的最小值                                         |
| Count      | 计算指定条件下的记录数                                       |
| StdDev     | 计算指定字段的标准差                                         |
| Variance   | 计算指定字段的方差                                           |
| Coalesce   | 返回第一个非空表达式的值                                     |
| Concat     | 将多个字符串连接成一个字符串                                 |
| Length     | 计算字符串字段的长度                                         |
| Upper      | 将字符串字段转换为大写                                       |
| Lower      | 将字符串字段转换为小写                                       |
| Trunc      | 截断日期或时间字段为指定的精度                               |
| Extract    | 从日期或时间字段中提取指定的部分（例如年、月、日、小时等）   |
| Case/When  | 根据条件进行条件判断和结果返回                               |
| F          | 在查询中引用模型字段，并进行数学运算或比较                   |
| Expression | 执行数据库级别的表达式操作，如数学运算、字符串操作等         |
| RawSQL     | 使用原生的SQL语句执行自定义的聚合操作，提供更高级的数据库功能 |



```python
# Avg：计算指定字段的平均值。

from myapp.models import Book
from django.db.models import Avg

avg_price = Book.objects.aggregate(avg_price=Avg('price'))['avg_price']


# Sum：计算指定字段的总和。
from myapp.models import Book
from django.db.models import Sum

total_sales = Book.objects.aggregate(total_sales=Sum('sales'))['total_sales']


# Max：获取指定字段的最大值。
from myapp.models import Book
from django.db.models import Max

max_price = Book.objects.aggregate(max_price=Max('price'))['max_price']


# Min：获取指定字段的最小值。
from myapp.models import Book
from django.db.models import Min

min_price = Book.objects.aggregate(min_price=Min('price'))['min_price']


# Count：计算指定条件下的记录数。
from myapp.models import Book
from django.db.models import Count

book_count = Book.objects.aggregate(book_count=Count('id'))['book_count']

```





# 16.关联查询1

```python
在 Django ORM 中，关联查询用于在模型之间建立关系并执行跨表查询。通过定义外键或多对多字段，您可以在模型之间创建关联关系，并使用相关字段进行查询。
```

```python
"""
在 Django ORM 中，一对一关系（One-to-One Relationship）是一种模型之间的关联关系，其中每个对象只能与另一个对象相关联。可以使用 OneToOneField 字段来定义一对一关系。
"""

from django.db import models

class Employee(models.Model):
    name = models.CharField(max_length=100)
    # 其他员工字段...

class Profile(models.Model):
    employee = models.OneToOneField(Employee, on_delete=models.CASCADE, related_name='profile')
    bio = models.TextField()
    # 其他个人资料字段...

"""
OneToOneField 字段用于在 Profile 模型中建立与 Employee 模型的一对一关系。
on_delete=models.CASCADE 指定了级联删除选项，表示如果 Employee 对象被删除，相关的 Profile 对象也会被删除。
related_name='profile' 为反向关联提供了一个名称，使得可以通过 Employee 对象访问其关联的 Profile 对象。
"""
    
    
# 查询员工 "John Doe" 的个人资料
employee = Employee.objects.get(name="John Doe")
profile = employee.profile


# 查询个人资料所属的员工姓名
profile = Profile.objects.get(id=1)
employee_name = profile.employee.name

```





```python
# 在Django中，一对多关系可以通过ForeignKey字段来实现。

from django.db import models

class Parent(models.Model):
    name = models.CharField(max_length=100)

class Child(models.Model):
    name = models.CharField(max_length=100)
    parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='children')

"""
在上述示例中，我们定义了两个模型类：Parent（父母）和Child（孩子）。它们之间的关系是一对多，一个父母可以有多个孩子，而一个孩子只能属于一个父母。

	Parent 类继承自 models.Model，表示它是一个Django模型类。
	name 字段是一个CharField，用于存储父母的名称。
	Child 类也继承自 models.Model。
	name 字段是一个CharField，用于存储孩子的名称。
	parent 字段是一个ForeignKey字段，它建立了Parent和Child之间的关系。on_delete=models.CASCADE 表示当父母被删除时，与之关联的所有孩子也会被删除。related_name='children' 定义了反向关系的名称，可以通过该名称在父母对象中访问其所有孩子。
"""

parent = Parent.objects.get(id=1)
children = parent.children.all()

```



```python
"""
ManyToManyField是Django中用于表示多对多关联关系的字段类型。它允许两个模型之间建立多对多的关系，其中一个模型可以与多个另一个模型的实例关联，反之亦然。


Student 类继承自 models.Model，表示它是一个Django模型类。
	name 字段是一个CharField，用于存储学生的姓名。


Course 类也继承自 models.Model。
	name 字段是一个CharField，用于存储课程的名称。
	students 字段是一个ManyToManyField，它建立了与Student模型的多对多关联关系。related_name='courses' 定义了反向关系的名称，可以通过该名称在学生对象中访问其选修的课程。
"""

from django.db import models

class Student(models.Model):
    name = models.CharField(max_length=100)

class Course(models.Model):
    name = models.CharField(max_length=100)
    students = models.ManyToManyField(Student, related_name='courses')

    
course = Course.objects.get(id=1)
students = course.students.all()

```



```python
"""
在多对多关联中，Django会自动生成一个中间表来处理关联关系。如果你想要更多地控制这个中间表，可以使用through参数来定义一个自定义的中间模型
"""


from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author, through='AuthorBook', related_name='books')

class AuthorBook(models.Model):
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    book = models.ForeignKey(Book, on_delete=models.CASCADE)

    class Meta:
        db_table = 'author_book'

# 创建作者
author = Author.objects.create(name='John Smith')

# 创建书籍
book = Book.objects.create(title='The Great Gatsby')

# 建立作者和书籍之间的关联
AuthorBook.objects.create(author=author, book=book)



# 获取特定作者的所有书籍
author = Author.objects.get(name='John Smith')
books = author.books.all()

# 获取特定书籍的所有作者
book = Book.objects.get(title='The Great Gatsby')
authors = book.authors.all()



# 更新关联记录
author_book = AuthorBook.objects.get(author=author, book=book)
author_book.book = new_book  # 将关联的书籍更新为新的书籍对象
author_book.save()

# 删除关联记录
author_book = AuthorBook.objects.get(author=author, book=book)
author_book.delete()


"""

from django.db import models

class Student(models.Model):
    name = models.CharField(max_length=100)

class Course(models.Model):
    name = models.CharField(max_length=100)

class Enrollment(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    course = models.ForeignKey(Course, on_delete=models.CASCADE)
    enrollment_date = models.DateField()  # 中间表添加一些其他字段

# 创建中间表记录
student = Student.objects.get(id=1)
course = Course.objects.get(id=1)
enrollment = Enrollment.objects.create(student=student, course=course, enrollment_date='2023-11-04')

"""
```





# 17.关联查询2

```python
from django.db import models

class BookInfo(models.Model):
    btitle = models.CharField(max_length=100)
    bpub_date = models.DateField()

    def __str__(self):
        return self.btitle

class HeroInfo(models.Model):
    hname = models.CharField(max_length=100)
    hgender = models.BooleanField(default=True)
    hbook = models.ForeignKey(BookInfo, on_delete=models.CASCADE)

    def __str__(self):
        return self.hname

```



```python
# 通过一方模型类对象访问多方对象：一方模型类对象.多方模型类名小写_set.all()    由一到多的访问语法
b = BookInfo.objects.get(id=1)
b.heroinfo_set.all()
```



```python
# 通过多方模型类对象访问一方对象：多方模型类对象.多方模型类中的关系类属性名  由多到一的访问语法
h = HeroInfo.objects.get(id=1)
h.hbook
```



```python
# 访问一方模型类关联对象的id语法   ---- 多方模型类对象.关联类属性_id
h = HeroInfo.objects.get(id=1)
h.hbook_id
```



````python
# 关联过滤查询
"""
由多模型类条件查询一模型类数据
----- 语法：关联模型类名小写__属性名__条件运算符=值
----- 注意：如果没有条件运算符部分，则表示等于。
"""
BookInfo.objects.filter(heroinfo__hname='孙悟空')  # 要求图书英雄为"孙悟空"：

BookInfo.objects.filter(heroinfo__hcomment__contains='八') # 要求图书中英雄的描述包含"八"



"""
由一模型类条件查询多模型类数据
----- 语法： 一模型类关联属性名__一模型类属性名__条件运算符=值
----- 注意： 如果没有条件运算符部分，则表示等于。
"""

HeroInfo.objects.filter(hbook__btitle='天龙八部')  # 查询书名为"天龙八部"的所有英雄

HeroInfo.objects.filter(hbook__bread__gt=30)  # 查询图书阅读量大于30的所有英雄

````











# 18.查询集

```
查询集（QuerySet）是Django中用于表示数据库查询结果的对象集合。它具有很多强大的方法，可以对数据进行过滤、排序、聚合等操作。
```

```
1. `all()`：返回查询集中的所有对象。

2. `filter(**kwargs)`：根据指定的条件筛选查询集中的对象。多个条件之间使用逻辑与（AND）进行组合。

    例如：`Book.objects.filter(author='John', year=2022)`

3. `exclude(**kwargs)`：排除符合指定条件的对象，返回不符合条件的对象。

    例如：`Book.objects.exclude(author='John')`

4. `get(**kwargs)`：获取单个对象，要求查询结果只有一个对象满足条件。如果没有或者有多个对象满足条件，则会抛出异常。

    例如：`Book.objects.get(id=1)`

5. `order_by(*fields)`：按照指定字段对查询集进行升序排序，默认为升序。可以通过在字段名前添加 `-` 来进行降序排序。

    例如：`Book.objects.order_by('title')` 或 `Book.objects.order_by('-price')`

6. `values(*fields)`：返回一个包含指定字段值的字典列表。每个字典代表一个对象，并且只包含指定字段的键值对。

    例如：`Book.objects.values('title', 'author')`

7. `annotate(*args, **kwargs)`：对查询集进行注解，计算额外的聚合数据并将其添加到每个对象中。

    例如：`Book.objects.annotate(total_pages=Sum('pages'))`

8. `count()`：返回查询集中对象的数量。

    例如：`Book.objects.count()`

9. `exists()`：检查查询集是否至少存在一个对象，返回布尔值。

    例如：`Book.objects.filter(author='John').exists()`

以上只是一些常见的查询集方法示例，Django还提供了更多强大的查询集方法和功能，如聚合函数（Sum、Avg等）、联结查询（F与Q对象）等。你可以根据具体需求在查询集上链式调用这些方法来实现复杂的数据库查询操作。
```





```
惰性执行：查询集是惰性加载的，即在访问或操作查询集之前，并不会立即执行数据库查询。只有在需要使用数据时，才会触发实际的数据库查询。

缓存：一旦执行了查询，查询集会将结果缓存起来以供后续使用。这意味着多次访问相同的查询集不会导致多次查询数据库，而是直接从缓存中获取数据。

可迭代性：查询集是可迭代的，你可以像处理列表一样遍历查询集中的对象。这使得在视图函数、模板中或其他地方对查询集进行循环和处理变得非常方便。

链式调用：查询集支持链式调用，可以在查询集上连续应用多个方法来进一步过滤、排序、聚合等操作。每个方法都返回一个新的查询集，允许你在不修改原始查询集的情况下进行操作。

数据延迟加载：查询集中的字段值不会立即加载到内存中，而是在访问字段值时才会从数据库中获取。这使得查询集更加高效，只加载所需的字段值，减少了不必要的数据传输和内存占用。

数据库操作：通过查询集，你可以执行各种数据库操作，如过滤、排序、聚合、更新和删除等。查询集提供了一组丰富的方法来处理和操作数据，使得与数据库的交互变得简单而灵活。
```





# 19.限制查询集

在Django中，你可以使用查询集（QuerySet）的方法来限制和调整查询结果。以下是一些常用的方法来限制查询集的大小和范围：

1. `filter()`：通过指定条件对查询集进行过滤，只返回满足条件的对象。

   例如：
   ```python
   books = Book.objects.filter(author='John')
   ```

2. `exclude()`：排除符合指定条件的对象，返回不满足条件的对象。

   例如：
   ```python
   books = Book.objects.exclude(author='John')
   ```

3. `order_by()`：按照指定字段对查询集进行排序。

   例如：
   ```python
   books = Book.objects.order_by('title')  # 按标题升序排序
   ```

4. `distinct()`：去除查询集中的重复记录。

   例如：
   ```python
   authors = Author.objects.distinct()  # 去除重复的作者记录
   ```

5. `values()`：指定要返回的字段，生成一个包含字段值的字典列表。

   例如：
   ```python
   book_titles = Book.objects.values('title')  # 返回所有书籍的标题
   ```

6. `values_list()`：类似于 `values()`，但返回的是一个包含字段值的元组列表。

   例如：
   ```python
   book_titles = Book.objects.values_list('title', flat=True)  # 返回所有书籍的标题列表
   ```

7. `first()`：返回查询集中的第一个对象。

   例如：
   ```python
   book = Book.objects.first()  # 获取第一本书
   ```

8. `last()`：返回查询集中的最后一个对象。

   例如：
   ```python
   book = Book.objects.last()  # 获取最后一本书
   ```

9. 切片（Slicing）：使用切片操作来限制查询集的结果范围。

   例如：
   ```python
   books = Book.objects.all()[:5]  # 返回前五本书
   ```

这些方法可以单独使用，也可以进行组合，以实现更复杂的查询和结果限制。你可以根据具体需求选择适当的方法来限制和调整查询集的大小和范围。



# 20.执行原生查询

```
若管理器方法 raw() 能用于执行原生 SQL 查询，就会返回模型实例：

Manager.raw(raw_query, params=(), translations=None)
该方法接受一个原生 SQL 查询语句，执行它，并返回一个 django.db.models.query.RawQuerySet 实例。
这个 RawQuerySet 能像普通的 QuerySet 一样被迭代获取对象实例。
```



```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    birth_date = models.DateField()   # 出生日期

    def __str__(self):
        return f"{self.first_name} {self.last_name}"


# 执行原生查询
for p in Person.objects.raw("SELECT * FROM myapp_person"):
    print(p)

"""
需要注意的是，当使用objects.raw()方法执行原生查询时，Django会将查询结果映射到模型类的实例对象上，使得你可以像操作普通查询集一样访问查询结果的字段值。

此外，你还可以在原生查询中使用参数化查询来防止SQL注入攻击，以及通过传递额外的参数给objects.raw()方法来替换查询中的占位符。具体用法请参考Django官方文档中关于objects.raw()方法的说明。
"""

这个例子并不令人激动——它与运行 Person.objects.all() 完全相同。然而， raw() 有很多额外选项，使得它非常强大。

```

```python
# 在本例中，Person 表的名称myapp_person是从哪来的？

默认情况下，Django 通过拼接模型的 "app label" 和模型类名推算出数据表名 —— 即你在 manage.py startapp 中使用的名称，二者以一个下划线分割。在本例中，我们假定 Person 模型位于一个叫做 myapp 的应用中，这样，模型的表名就是 myapp_person。



"""
不会对传给 .raw() 的 SQL 语句做任何检查。Django 期望该语句会从数据库中返回一个集合，但并不强制如此。若该查询没有返回一些记录，会导致一个（含糊）的错误。


若你在 MySQL 上执行查询，至于其无声的强制类型可能会弄混类型时导致不可预料的后果。
若你用一个整数值查询一个字符串列，MySQL 会执行比较前将表中所有数据强制转为整数。例如，若数据表包含的值有 'abc' 和 'def'，而查询语句为 WHERE mycolumn=0，这两行都会匹配上。要避免这种情况，在将值传给查询语句前进行合适的类型转换。
"""
```



```shell
# raw() 字段将查询语句中的字段映射至模型中的字段

>>> Person.objects.raw("SELECT id, first_name, last_name, birth_date FROM myapp_person")
>>> Person.objects.raw("SELECT last_name, birth_date, first_name, id FROM myapp_person")

>>> Person.objects.raw(
...     """
...     SELECT first AS first_name,
...            last AS last_name,
...            bd AS birth_date,
...            pk AS id,
...     FROM some_other_table
...     """
... )
```

```shell
# 只要名字对上了，模型实例就会被正确创建。
# 或者，可以使用raw（）的translations参数将查询中的字段映射到模型字段。这是一个字典，将查询中字段的名称映射到模型上字段的名称。例如，上面的查询也可以写成：
>>> name_map = {"first": "first_name", "last": "last_name", "bd": "birth_date", "pk": "id"}
>>> Person.objects.raw("SELECT * FROM some_other_table", translations=name_map)
```



```shell
# 索引查询

"""
# raw（）支持索引，因此如果只需要第一个结果，则可以编写：
"""

>>> first_person = Person.objects.raw("SELECT * FROM myapp_person")[0]


"""
# 但是，索引和切片不是在数据库级别执行的。如果数据库中有大量Person对象，则将查询限制在SQL级别会更有效：
"""
>>> first_person = Person.objects.raw("SELECT * FROM myapp_person LIMIT 1")[0]
```



```python
# 延迟模型字段

>>> people = Person.objects.raw("SELECT id, first_name FROM myapp_person")

"""
此查询返回的Person对象将是延迟的模型实例。这意味着查询中省略的字段将根据需要加载。例如：
"""

>>> for p in Person.objects.raw("SELECT id, first_name FROM myapp_person"):
...     print(
...         p.first_name,  # 这将由原始查询检索
...         p.last_name,  # 这将按需检索
...     )
...
John Smith
Jane Jones

"""
从外观上看，查询似乎同时检索了名字和姓氏。然而，这个例子实际上发出了3个查询。raw（）查询只检索第一个名字 ------ last names都是在打印时按需检索的。
"""

# 只有一个字段你不能省略 -- 主键字段。
# Django 用主键来区分模型实例，所以必须在原生查询语句中包含主键。若你忘了包含主键会抛出 FieldDoesNotExist 异常。

```



```python
# 添加注释
"""
您还可以执行包含未在模型中定义的字段的查询。例如，我们可以使用PostgreSQL的age（）函数来获取一个由数据库计算年龄的人的列表：
"""

>>> people = Person.objects.raw("SELECT *, age(birth_date) AS age FROM myapp_person")
>>> for p in people:
...     print("%s is %s." % (p.first_name, p.age))
...
John is 37.
Jane is 42.
...


```

```python
# 将参数传给 raw()   

>>> lname = "Doe"
>>> Person.objects.raw("SELECT * FROM myapp_person WHERE last_name = %s", [lname])

"""
params 是一个参数字典。你将用一个列表替换查询字符串中 %s 占位符，或用字典替换 %(key)s 占位符（key 被字典 key 替换），不论你使用哪个数据库引擎。这些占位符会被 params 参数的值替换。
"""

"""
----- 不要对原生查询或 SQL 字符串中的引号占位符使用字符串格式化！
"""
很容易将上述查询写成：
>>> query = "SELECT * FROM myapp_person WHERE last_name = %s" % lname
>>> Person.objects.raw(query)

您可能还认为应该这样写查询（在%s周围加引号）：
>>> query = "SELECT * FROM myapp_person WHERE last_name = '%s'"

"""
防御 SQL 注入 介绍的，使用 params 参数和不用引号包裹占位符使你免受 SQL 注入攻击，这是一个攻击者常用的漏洞，将任意 SQL 注入你的数据库。若你使用了字符串插入或用引号包裹占位符，你正处于 SQL 注入的风险中。
"""
```



# 21.执行自定义sql

```python
有时候，甚至 Manager.raw() 都无法满足需求：你可能要执行不明确映射至模型的查询语句，或者就是直接执行 UPDATE， INSERT 或 DELETE 语句。


这些情况下，你总是能直接访问数据库，完全绕过模型层。
```

```python
"""
对象 django.db.connection 代表默认数据库连接。
要使用这个数据库连接，调用 connection.cursor() 来获取一个指针对象。
然后，调用 cursor.execute(sql, [params]) 来执行该 SQL 和 cursor.fetchone()，或 cursor.fetchall() 获取结果数据。
"""

from django.db import connection


def my_custom_sql(self):
    with connection.cursor() as cursor:
        cursor.execute("UPDATE bar SET foo = 1 WHERE baz = %s", [self.baz])
        cursor.execute("SELECT foo FROM bar WHERE baz = %s", [self.baz])
        row = cursor.fetchone()

    return row



"""
要避免 SQL 注入，你绝对不能在 SQL 字符串中用引号包裹 %s 占位符。

注意，若要在查询中包含文本的百分号，你需要在传入参数使用两个百分号:
"""
cursor.execute("SELECT foo FROM bar WHERE baz = '30%'")
cursor.execute("SELECT foo FROM bar WHERE baz = '30%%' AND id = %s", [self.id])




"""
若你同时使用 不止一个数据库，你可以使用 django.db.connections 获取指定数据库的连接（和指针）。
django.db.connections 是一个类字典对象，它允许你通过连接别名获取指定连接:
"""
from django.db import connections

with connections["my_db_alias"].cursor() as cursor:
    # Your code here
    ...

    
"""
默认情况下，Python DB API 返回的结果不会包含字段名，这意味着你最终会收到一个 list，而不是一个 dict。
要追求较少的运算和内存消耗，你可以以 dict 返回结果，通过使用如下的玩意:

cursor.description 属性来获取查询结果的描述信息。该属性返回一个包含查询结果列的元组列表，每个元组包含了列的详细信息。
"""
def dictfetchall(cursor):
    """
    将光标中的所有行作为dict返回。
    假设列名是唯一的。
    """
    columns = [col[0] for col in cursor.description]
    return [dict(zip(columns, row)) for row in cursor.fetchall()]




"""
另一个选项是使用来自 Python 标准库的 collections.namedtuple()。
namedtuple 是一个类元组对象，可以通过属性查找来访问其包含的字段；也能通过索引和迭代
。结果都是不可变的，但能通过字段名或索引访问，这很实用:

cursor.description 属性来获取查询结果的描述信息。该属性返回一个包含查询结果列的元组列表，每个元组包含了列的详细信息。
"""
from collections import namedtuple


def namedtuplefetchall(cursor):
    """
    将光标中的所有行作为命名元组返回。
    假设列名是唯一的。
    """
    desc = cursor.description
    nt_result = namedtuple("Result", [col[0] for col in desc])
    return [nt_result(*row) for row in cursor.fetchall()]



"""
dictfetchall（）和namedtuplefetchall）示例采用唯一的列名，因为游标无法区分不同表中的列。以下是三者之间的区别示例：
"""
>>> cursor.execute("SELECT id, parent_id FROM test LIMIT 2")
>>> cursor.fetchall()
((54360982, None), (54360880, None))

>>> cursor.execute("SELECT id, parent_id FROM test LIMIT 2")
>>> dictfetchall(cursor)
[{'parent_id': None, 'id': 54360982}, {'parent_id': None, 'id': 54360880}]

>>> cursor.execute("SELECT id, parent_id FROM test LIMIT 2")
>>> results = namedtuplefetchall(cursor)
>>> results
[Result(id=54360982, parent_id=None), Result(id=54360880, parent_id=None)]
>>> results[0].id
54360982
>>> results[0][0]
54360982
```



```python
# 连接与指针
"""
connection 和 cursor 实现了 PEP 249 中介绍的大部分标准 Python DB-API —— 除了 事务处理 之外。

若你并不熟悉 Python DB-API，要注意 cursor.execute() 中的 SQL 语句使用了占位符 "%s"，而不是直接在 SQL 中添加参数。若你使用这个技巧，潜在的数据库库会自动在需要时转义参数。

也要注意，Django 期望 "%s" 占位符，而 不是 "?" 占位符，后者由 SQLite Python 绑定使用。这是为了一致性和正确性。

将指针作为上下文的管理器:

query = "SELECT * FROM person WHERE age >= %s AND age <= %s"
params = (min_age, max_age)
"""
with connection.cursor() as c:
    c.execute(...)  # cursor.execute(query, params)
    
"""
相当于
"""
c = connection.cursor()
try:
    c.execute(...)
finally:
    c.close()
```





# 22.模型类元数据

```
在 Django 的模型类中，可以通过使用元数据（Metadata）来提供关于模型的附加信息和配置。元数据是模型类的一个内部类 Meta，其中包含了一些属性和选项，用于定义模型的行为和特性。
```



```python
# verbose_name 和 verbose_name_plural：
"""
用于指定模型在管理后台中显示的名称。verbose_name 表示单数形式的名称，而 verbose_name_plural 表示复数形式的名称。
"""
class Book(models.Model):
    title = models.CharField(max_length=100)

    class Meta:
        verbose_name = '书籍'
        verbose_name_plural = '书籍'

```



```python
# ordering：
"""
用于指定模型在数据库中的默认排序顺序。可以根据一个或多个字段进行排序，并使用负号 - 来表示降序排序
"""

class Book(models.Model):
    title = models.CharField(max_length=100)
    publication_date = models.DateField()

    class Meta:
        ordering = ['-publication_date']

```



```python
# db_table：
"""
用于指定模型在数据库中对应的表名。如果不指定，默认的表名将由 Django 自动生成。
"""

class Book(models.Model):
    title = models.CharField(max_length=100)

    class Meta:
        db_table = 'my_book_table'

```



```python
# unique_together
"""
用于指定模型中多个字段的联合唯一性约束。这意味着这些字段的组合值在数据库中必须是唯一的。
"""

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

    class Meta:
        unique_together = ['title', 'author']

```



```python
# get_latest_by
"""
用于指定模型中的日期或时间字段，以便 Django 可以通过该字段获取最新的对象
"""

class Article(models.Model):
    title = models.CharField(max_length=100)
    pub_date = models.DateTimeField()

    class Meta:
        get_latest_by = 'pub_date'

```



```python
# permissions：

"""
用于定义模型的权限。可以指定哪些用户或用户组具有对模型进行特定操作的权限
"""
class Book(models.Model):
    title = models.CharField(max_length=100)

    class Meta:
        permissions = [
            ("view_book", "Can view book"),
            ("edit_book", "Can edit book"),
        ]

```



```python
# abstract
"""
用于指示模型为抽象基类，即不会生成对应的数据库表。抽象基类可被其他模型继承并共享其字段和方法。
"""
class BaseModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True

class Book(BaseModel):
    title = models.CharField(max_length=100)

```



```python
# indexes
"""
用于定义模型中字段的索引。索引可以提高查询性能
"""

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

    class Meta:
        indexes = [
            models.Index(fields=['title']),
            models.Index(fields=['author']),
        ]
"""
我们为 title 字段和 author 字段分别创建了索引。这样，当进行相关的查询时，数据库将使用这些索引来快速查找匹配的记录，提高查询性能。

需要注意的是，创建索引可能会对数据库的写入操作产生一些额外开销。因此，应该根据具体的查询需求和数据库负载情况来权衡是否创建索引。
"""
```



```python
# default_related_name
"""
用于指定反向关联关系的默认名称，允许通过关系属性进行反向查询
"""
class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

    class Meta:
        default_related_name = 'books'

```



```python
# app_label：
"""
用于指定模型所属的应用程序名称
"""
class Book(models.Model):
    title = models.CharField(max_length=100)

    class Meta:
        app_label = 'myapp'

```



```python
# abstract_base_classes：
"""
用于标记模型为抽象基类的一部分，并将其字段合并到子类中
"""

class BaseModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True

class Book(BaseModel):
    title = models.CharField(max_length=100)

    class Meta:
        abstract_base_classes = (BaseModel,)

```



你可以查阅 Django 官方文档中的[模型元数据选项](https://docs.djangoproject.com/en/3.2/ref/models/options/#model-meta-options)来了解更多选项和详细信息。

















